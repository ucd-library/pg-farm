import pgFormat from 'pg-format';
import client from '../lib/pg-admin-client.js';
import kubectl from '../lib/kubectl.js';
import config from '../lib/config.js';
import keycloak from '../lib/keycloak.js';
import pgInstClient from '../lib/pg-instance-client.js';
import logger from '../lib/logger.js';
import modelUtils from './utils.js';
import {getContext, createContext} from '../lib/context.js';

class PgRest {

  /**
   * @method generateConfigFile
   * @description Generate the PostgREST config file for the given database and organization.
   * Called by the pg-rest service to generate the config file for the PostgREST container
   * on startup.  These params are passed in via env vars so they are not passed as ctx.
   * 
   * @param {String} dbNameOrId database name or id
   * @param {String} orgNameOrId organization name or id
   * @returns 
   */
  async generateConfigFile(dbNameOrId, orgNameOrId=null) {
    let ctx = await createContext({
      database : dbNameOrId,
      organization : orgNameOrId,
    });

    let instance = ctx.instance;
    let database = ctx.database;
    let user = await this.models.user.get(ctx, config.pgRest.authenticator.username);
    let keys = JSON.stringify(JSON.stringify(await keycloak.getJWKS()));

    let escapedPass = encodeURIComponent(user.password);
    let escapedUser = encodeURIComponent(user.username);

    let conStr = `postgresql://${escapedUser}:${escapedPass}@${instance.hostname}:${instance.port}/${database.name}`;
    let file = `# postgrest.conf
# Generated by pg-farm ${new Date().toISOString()}

db-uri = "${conStr}"

db-schema = "${config.pgRest.schema}"
db-anon-role = "${config.pgInstance.publicRole.username}"

jwt-secret = ${keys}
jwt-role-claim-key = ".preferred_username"

openapi-server-proxy-uri = "${config.appUrl}/api/query/${ctx.fullDatabaseName}"

server-port = ${config.pgRest.port}`
    return file;
  }

  /**
   * @method initDb
   * @description Initialize the database for PostgREST roles and schema
   * 
   * @param {String|Object} ctx context object or id
   * 
   * @returns {Promise}
   */
  async initDb(ctx) {
    logger.info('Initializing database for PostgREST', ctx.logSignal);

    let con = await this.models.database.getConnection(ctx);

    // add authenticator user
    logger.info('Ensuring authenticator user', config.pgRest.authenticator.username, ctx.logSignal);
    await this.models.user.create(ctx, config.pgRest.authenticator.username);

    // create the api schema
    logger.info('Ensuring schema', config.pgRest.schema, ctx.logSignal);
    await pgInstClient.ensurePgSchema(con, config.pgRest.schema);

    // grant usage on the api schema to the public role
    logger.info('Granting usage on schema to public role',
      logger.objToString({schema: config.pgRest.schema, user: config.pgInstance.publicRole.username}),
      ctx.logSignal
    );
    let formattedQuery = pgFormat('GRANT USAGE ON SCHEMA %s TO "%s"', 
      config.pgRest.schema, config.pgInstance.publicRole.username
    );
    await pgInstClient.query(con, formattedQuery);

    // grant the public role to the authenticator user
    await this.grantUserAccess(ctx, config.pgInstance.publicRole.username, con);
  }

  /**
   * @method grantUserAccess
   * @description Grant pgrest authenticator the role of the given user.  This allows the authenticator
   * to impersonate the user when making requests to the database via a JWT token.
   * 
   * @param {String|Object} ctx context object or id
   * @param {String} username username to grant access
   * @param {Object} con optional.  A postgres connection object
   * 
   * @returns {Promise}
   */
  async grantUserAccess(ctx, username, con=null) {
    if( username === config.pgInstance.adminRole ) {
      logger.warn('Cannot grant authenticator access to admin role: '+username, ctx.logSignal);
      return;
    }
    
    if( !con ) {
      con = await this.models.instance.getConnection(ctx);
    }

    logger.info('Granting role to authenticator user',
      logger.objToString({username, role: config.pgRest.authenticator.username}),
      ctx.logSignal
    );
    let formattedQuery = pgFormat('GRANT "%s" TO "%s"', 
      username, config.pgRest.authenticator.username
    );
    await pgInstClient.query(con, formattedQuery);
  }

  /**
   * @method start
   * @description Start the PostgREST service for the given database and organization.
   * 
   * @param {String|Object} ctx context object or id
   * @returns 
   */
  async start(ctx) {
    ctx = getContext(ctx);

    if( config.k8s.enabled === false ) {
      logger.warn('K8s is not enabled, just setting state to RUN');
      return;
    }

    logger.info('Starting PostgREST', ctx.logSignal);

    let database = ctx.database;
    let orgName = ctx.organization?.name || '';

    let templates = await modelUtils.getTemplate('pgrest');

    // PostgREST
    let hostname = database.pgrest_hostname;
    let k8sConfig = templates.find((t) => t.kind === 'Deployment');
    k8sConfig.metadata.name = hostname;
    
    let spec = k8sConfig.spec;
    spec.selector.matchLabels.app = hostname;

    let template = spec.template;
    template.metadata.labels.app = hostname;

    let container = template.spec.containers[0];
    container.image = config.pgRest.image;
    container.name = 'pgrest';

    container.env[0].value = database.name;
    container.env[1].value = orgName;
    container.env.push({
      name : 'APP_URL',
      value : config.appUrl
    });

    modelUtils.cleanTemplateForLocalDev(k8sConfig);

    let pgrestResult = await kubectl.apply(k8sConfig, {
      stdin: true,
      isJson: true
    });

    // PostgREST
    k8sConfig = templates.find((t) => t.kind === 'Service');
    k8sConfig.metadata.name = hostname;
    k8sConfig.spec.selector.app = hostname;

    let pgrestServiceResult = await kubectl.apply(k8sConfig, {
      stdin:true,
      isJson: true
    });

    return {pgrestResult, pgrestServiceResult, hostname};
  }

  /**
   * @method restart
   * @description Restart the PostgREST service for the given database and organization.
   * 
   * @param {String|Object} ctx context object or id
   * @returns 
   */
  async restart(ctx) {
    ctx = getContext(ctx);

    logger.info('Restarting PostgREST', ctx.logSignal);

    let {hostname} = await this.start(ctx);
    await kubectl.restart('deployment', hostname);
  }

  /**
   * @method stop
   * @description Stop the PostgREST service for the given database and organization.
   * 
   * @param {String|Object} ctx context object or id
   * @returns
   */
  async stop(ctx) {
    ctx = getContext(ctx);

    logger.info('Stopping PostgREST', ctx.logSignal);

    let database = ctx.database;
    let hostname = database.pgrest_hostname;

    logger.info('Stopping PostgREST: '+hostname);

    let pgrestResult, pgrestServiceResult;

    try {
      pgrestResult = await kubectl.delete('deployment', hostname);
    } catch(e) {
      logger.warn('Error deleting statefulset', e.message);
      pgrestResult = {
        message : e.message,
        stack : e.stacks
      }
    }

    try {
      pgrestServiceResult = await kubectl.delete('service', hostname);
    } catch(e) {
      logger.warn('Error deleting service', e.message);
      pgrestServiceResult = {
        message : e.message,
        stack : e.stacks
      }
    }

    return {pgrestResult, pgrestServiceResult};
  }

}

const instance = new PgRest();
export default instance;